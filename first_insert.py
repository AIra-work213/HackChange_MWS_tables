# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12MuX8wstiC6cjZMqI282TA3B_OUChl4K
"""

import requests
import pandas as pd
import numpy as np
from tqdm import tqdm
import time
import logging
from datetime import datetime, timedelta
import warnings
import concurrent.futures
from threading import Lock
import random

# –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
warnings.filterwarnings('ignore', category=FutureWarning)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.WARNING)

# ID –≥—Ä—É–ø–ø –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ —Å–≤—è–∑–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
VK_GROUPS = {
    '-8458649': '–ú–¢–°',
    '-26514504': '–ë–∏–ª–∞–π–Ω',
    '-18098621': '–¢–µ–ª–µ2',
    '-50353992': '–ô–æ—Ç–∞',
    '-3785': '–ú–µ–≥–∞—Ñ–æ–Ω'
}

VK_TOKEN = '954e97ed954e97ed954e97ed2d967306909954e954e97edfc65b931ccd5ae0f3c2a7afe'

# MWS –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
MWS_URL = "https://tables.mws.ru/fusion/v1/datasheets/dstRtSXBewJh8lLCNz/records"
MWS_HEADERS = {
    "Authorization": "Bearer uskSID2MFKEnL7AVNUdLrnn",
    "Content-Type": "application/json"
}
MWS_PARAMS = {
    "viewId": "viwYvxvon7TBU",
    "fieldKey": "name"
}

# –õ–∏–º–∏—Ç –ø–æ—Å—Ç–æ–≤ –Ω–∞ –≥—Ä—É–ø–ø—É
MAX_POSTS_PER_GROUP = 8000

# –î–∞—Ç–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è - 11 –Ω–æ—è–±—Ä—è 2025
CUTOFF_DATE = datetime(2025, 11, 11)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—á–µ—Ç—á–∏–∫–∏
success_count = 0
error_count = 0
counter_lock = Lock()

class VKDataCollector:
    def __init__(self, vk_token, api_version='5.199'):
        self.vk_token = vk_token
        self.api_version = api_version
        self.base_url = 'https://api.vk.com/method/'
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

    def get_wall_posts(self, owner_id, offset=0, count=100, end_time=None):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ —Å–æ —Å—Ç–µ–Ω—ã –¥–æ —É–∫–∞–∑–∞–Ω–Ω–æ–π –¥–∞—Ç—ã"""
        time.sleep(0.1)

        method = 'wall.get'
        params = {
            'access_token': self.vk_token,
            'owner_id': owner_id,
            'v': self.api_version,
            'offset': offset,
            'count': count,
            'extended': 0
        }

        if end_time:
            params['end_time'] = int(end_time.timestamp())

        try:
            response = self.session.get(f"{self.base_url}{method}", params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            if 'error' in data:
                error_code = data['error'].get('error_code')
                if error_code in [6, 9, 29]:
                    time.sleep(2)
                return None

            return data

        except Exception:
            return None

    def calculate_er(self, likes, reposts, comments, views):
        if not views or views == 0:
            return 0
        return ((likes + reposts + comments) / views) * 100

    def categorize_efficiency(self, er):
        if er >= 8:
            return "–í—ã—Å–æ–∫–∞—è"
        elif er >= 4:
            return "–°—Ä–µ–¥–Ω—è—è"
        elif er >= 2:
            return "–ù–∏–∑–∫–∞—è"
        else:
            return "–û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è"

    def extract_post_data(self, post, group_name):
        try:
            post_id = post.get('id')
            owner_id = post.get('owner_id')
            date_timestamp = post.get('date')
            text = post.get('text', '')

            likes = post.get('likes', {}).get('count', 0)
            reposts = post.get('reposts', {}).get('count', 0)
            comments = post.get('comments', {}).get('count', 0)
            views = post.get('views', {}).get('count') if post.get('views') else 0

            title = ''
            for attachment in post.get('attachments', [])[:2]:
                attachment_type = attachment.get('type')
                if attachment_type in ['link', 'video', 'photo']:
                    attachment_data = attachment.get(attachment_type, {})
                    title = attachment_data.get('title', '')[:300]
                    break

            er = self.calculate_er(likes, reposts, comments, views)
            efficiency = self.categorize_efficiency(er)

            return {
                'id_group': group_name,
                'id_post': post_id,
                'date_time': date_timestamp,
                'title': title,
                'text': text[:1000],
                'views': views,
                'likes': likes,
                'reposts': reposts,
                'comments': comments,
                'ER': round(er, 2),
                'Efficiency': efficiency,
                'day_of_week': ["–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫", "–í—Ç–æ—Ä–Ω–∏–∫", "–°—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä–≥", "–ü—è—Ç–Ω–∏—Ü–∞", "–°—É–±–±–æ—Ç–∞", "–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"][datetime.fromtimestamp(date_timestamp).weekday()],
                'date': datetime.fromtimestamp(date_timestamp).strftime('%Y-%m-%d'),
                'time_period': self.get_time_period(date_timestamp),
                'len_text': len(text)
            }

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å—Ç–∞: {e}")
            return None

    def get_time_period(self, timestamp):
        hour = datetime.fromtimestamp(timestamp).hour
        if 6 <= hour < 12:
            return "–£—Ç—Ä–æ"
        elif 12 <= hour < 18:
            return "–î–µ–Ω—å"
        elif 18 <= hour < 24:
            return "–í–µ—á–µ—Ä"
        else:
            return "–ù–æ—á—å"

def upload_batch_to_mws(posts_data):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –±–∞—Ç—á–∞ –ø–æ—Å—Ç–æ–≤ –≤ MWS –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤"""
    global success_count, error_count

    if not posts_data:
        return 0

    print(f"üì§ –ó–∞–≥—Ä—É–∂–∞–µ–º {len(posts_data)} –ø–æ—Å—Ç–æ–≤")

    records = []
    for post in posts_data:
        records.append({
            "post_id": str(post['id_post']),
            "title": str(post['title']),
            "text": str(post['text']),
            "attachment_description": "–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç",
            "views": int(post['views']),
            "likes": int(post['likes']),
            "reposts": int(post['reposts']),
            "comments_count": int(post['comments']),
            "comments": "–ù–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤",
            "post_date_time": int(post['date_time']) * 1000,
            "owner_id": str(post['id_group']),
            "ER": float(post['ER']),
            "Efficiency": str(post['Efficiency']),
            "day_of_week": str(post['day_of_week']),
            "post_date": int(post['date_time']) * 1000,
            "time_period": str(post['time_period']),
            "len_text": int(post['len_text'])
        })

    data = {
        "records": [{'fields': record} for record in records],
        "fieldKey": "name"
    }

    try:
        response = requests.post(
            MWS_URL,
            params=MWS_PARAMS,
            headers=MWS_HEADERS,
            json=data,
            timeout=15
        )

        if response.status_code in [200, 201]:
            with counter_lock:
                success_count += len(posts_data)
            print(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ {len(posts_data)} –ø–æ—Å—Ç–æ–≤")
            return len(posts_data)
        else:
            print(f"‚ùå –û—à–∏–±–∫–∞ –±–∞—Ç—á–µ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏: {response.status_code} - {response.text}")
            # Fallback –Ω–∞ –æ–¥–∏–Ω–æ—á–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É
            successful = 0
            for post in posts_data:
                if upload_single_post(post):
                    successful += 1
            return successful

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –±–∞—Ç—á–µ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
        # Fallback –Ω–∞ –æ–¥–∏–Ω–æ—á–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É
        successful = 0
        for post in posts_data:
            if upload_single_post(post):
                successful += 1
        return successful

def upload_single_post(post_data):
    """–ó–∞–≥—Ä—É–∑–∫–∞ –æ–¥–Ω–æ–≥–æ –ø–æ—Å—Ç–∞ –≤ MWS –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤"""
    global success_count, error_count

    post_id = str(post_data['id_post'])

    try:
        record = {
            "post_id": post_id,
            "title": str(post_data['title']),
            "text": str(post_data['text']),
            "attachment_description": "–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç",
            "views": int(post_data['views']),
            "likes": int(post_data['likes']),
            "reposts": int(post_data['reposts']),
            "comments_count": int(post_data['comments']),
            "comments": "–ù–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤",
            "post_date_time": int(post_data['date_time']) * 1000,
            "owner_id": str(post_data['id_group']),
            "ER": float(post_data['ER']),
            "Efficiency": str(post_data['Efficiency']),
            "day_of_week": str(post_data['day_of_week']),
            "post_date": int(post_data['date_time']) * 1000,
            "time_period": str(post_data['time_period']),
            "len_text": int(post_data['len_text'])
        }

        data = {
            "records": [{'fields': record}],
            "fieldKey": "name"
        }

        response = requests.post(
            MWS_URL,
            params=MWS_PARAMS,
            headers=MWS_HEADERS,
            json=data,
            timeout=10
        )

        if response.status_code in [200, 201]:
            with counter_lock:
                success_count += 1
            return True
        else:
            error_text = response.text.lower()
            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
            if "duplicate" in error_text or "—É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç" in error_text:
                print(f"‚ö†Ô∏è –ü–æ—Å—Ç {post_id} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º)")
                with counter_lock:
                    success_count += 1  # –°—á–∏—Ç–∞–µ–º –∫–∞–∫ —É—Å–ø–µ—à–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
                return True
            else:
                print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å—Ç–∞ {post_id}: {response.status_code} - {response.text}")
                with counter_lock:
                    error_count += 1
                return False

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥–ª—è –ø–æ—Å—Ç–∞ {post_id}: {e}")
        with counter_lock:
            error_count += 1
        return False

def collect_posts_from_group(owner_id, group_name):
    """–°–±–æ—Ä –ø–æ—Å—Ç–æ–≤ –∏–∑ –≥—Ä—É–ø–ø—ã –¥–æ 11.11.2025 —Å –ª–∏–º–∏—Ç–æ–º 8000"""
    global success_count, error_count

    collector = VKDataCollector(VK_TOKEN)

    print(f"üë• –ì—Ä—É–ø–ø–∞ {group_name}: —Å–±–æ—Ä –ø–æ—Å—Ç–æ–≤ –¥–æ {CUTOFF_DATE}")

    # –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å—Ç–æ–≤
    test_data = collector.get_wall_posts(owner_id, 0, 1, CUTOFF_DATE)
    if not test_data:
        print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}")
        return 0

    total_posts = test_data['response']['count']
    print(f"üìä –í—Å–µ–≥–æ –ø–æ—Å—Ç–æ–≤ –≤ –≥—Ä—É–ø–ø–µ: {total_posts}")

    if total_posts == 0:
        print(f"üì≠ –ü–æ—Å—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return 0

    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç–æ–º
    posts_to_collect = min(total_posts, MAX_POSTS_PER_GROUP)
    print(f"üéØ –ë—É–¥–µ—Ç —Å–æ–±—Ä–∞–Ω–æ: {posts_to_collect} –ø–æ—Å—Ç–æ–≤")

    # –°–æ–±–∏—Ä–∞–µ–º –∏ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Å—Ç—ã
    offset = 0
    processed_count = 0

    with tqdm(total=posts_to_collect, desc=f"–ì—Ä—É–ø–ø–∞ {group_name}") as pbar:
        while processed_count < posts_to_collect:
            remaining = posts_to_collect - processed_count
            count = min(100, remaining)

            wall_data = collector.get_wall_posts(owner_id, offset, count, CUTOFF_DATE)
            if not wall_data:
                break

            posts = wall_data['response']['items']
            if not posts:
                break

            batch_posts = []
            for post in posts:
                if processed_count >= posts_to_collect:
                    break

                post_data = collector.extract_post_data(post, group_name)
                if post_data:
                    batch_posts.append(post_data)
                processed_count += 1
                pbar.update(1)

            if batch_posts:
                upload_batch_to_mws(batch_posts)

            offset += 100
            time.sleep(0.3)

    print(f"‚úÖ –ì—Ä—É–ø–ø–∞ {group_name}: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {processed_count} –ø–æ—Å—Ç–æ–≤")
    return processed_count

def main_full_export():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª–Ω–æ–π –≤—ã–≥—Ä—É–∑–∫–∏"""
    global success_count, error_count

    print("üöÄ –ó–ê–ü–£–°–ö –ü–û–õ–ù–û–ô –í–´–ì–†–£–ó–ö–ò –î–ê–ù–ù–´–•")
    print("üéØ –†–µ–∂–∏–º: —Å–±–æ—Ä –≤—Å–µ—Ö –ø–æ—Å—Ç–æ–≤ –¥–æ 11.11.2025")
    print(f"üìä –õ–∏–º–∏—Ç: {MAX_POSTS_PER_GROUP} –ø–æ—Å—Ç–æ–≤ –Ω–∞ –≥—Ä—É–ø–ø—É")
    print(f"üìÖ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –¥–∞—Ç–µ: –¥–æ {CUTOFF_DATE}")
    print("üõ°Ô∏è  –ó–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤: –û–¢–ö–õ–Æ–ß–ï–ù–ê")
    print("üè∑Ô∏è  –í–ª–∞–¥–µ–ª–µ—Ü –ø–æ—Å—Ç–∞: –Ω–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã")
    print(f"üìã –¶–µ–ª–µ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞: {MWS_URL}")
    print("=" * 60)

    start_time = time.time()

    # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏
    success_count = 0
    error_count = 0

    total_processed = 0

    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≥—Ä—É–ø–ø—ã
    for i, (owner_id, group_name) in enumerate(VK_GROUPS.items()):
        print(f"\n{'='*50}")
        print(f"üîÑ –ì—Ä—É–ø–ø–∞ {i+1}/{len(VK_GROUPS)}: {group_name} ({owner_id})")
        print(f"{'='*50}")

        processed = collect_posts_from_group(owner_id, group_name)
        total_processed += processed

        if i < len(VK_GROUPS) - 1:
            time.sleep(1)

    total_time = time.time() - start_time

    print(f"\n{'='*60}")
    print("üìä –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê")
    print(f"{'='*60}")
    print(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ: {success_count}")
    print(f"‚ùå –û—à–∏–±–æ–∫: {error_count}")
    print(f"üìÑ –í—Å–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {total_processed}")
    print(f"‚è±Ô∏è –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {total_time:.1f} —Å–µ–∫")
    print(f"üìÖ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –¥–∞—Ç–µ: –¥–æ {CUTOFF_DATE}")

    if success_count > 0:
        print(f"\nüéâ –ü–û–õ–ù–ê–Ø –í–´–ì–†–£–ó–ö–ê –£–°–ü–ï–®–ù–û –ó–ê–í–ï–†–®–ï–ù–ê!")
        print(f"üí´ –î–æ–±–∞–≤–ª–µ–Ω–æ {success_count} –ø–æ—Å—Ç–æ–≤")
        print(f"üè∑Ô∏è  –í–ª–∞–¥–µ–ª—å—Ü—ã –ø–æ—Å—Ç–æ–≤: –Ω–∞–∑–≤–∞–Ω–∏—è –≥—Ä—É–ø–ø")
    else:
        print(f"\n‚ÑπÔ∏è –ü–æ—Å—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

if __name__ == "__main__":
    main_full_export()